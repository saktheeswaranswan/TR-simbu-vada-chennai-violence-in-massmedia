// === Multi-person Pose Viewer + Connector + CSV Export ===
// Paste into editor.p5js.org. Upload 'simbuu.json' (required), optional video/head files.
// Removes on-canvas JSON inspector. Adds Export CSV to save per-frame similarity metrics.

const FPS = 30;
const POSE_W = 640, POSE_H = 480;
const EDGES = [
  [5,7],[7,9],[6,8],[8,10],
  [11,13],[13,15],[12,14],[14,16],
  [5,6],[11,12],[5,11],[6,12]
];

let app;

function preload(){
  app = new App('Hghdugfy.mp4', 'tr-sulakarupan-adida.json', 'head.png');
  app.preload();
}
function setup(){ createCanvas(1280,720); frameRate(FPS); app.setup(); }
function draw(){ app.tick(); }
function mousePressed(){ app.onMousePressed(); }
function mouseDragged(){ app.onMouseDragged(); }
function mouseReleased(){ app.onMouseReleased(); }
function keyPressed(){ app.onKey(key.toUpperCase()); }
function mouseWheel(e){
  // Inspector removed â€” no scroll interaction needed here.
  return true;
}

// ---------------- App ----------------
class App {
  constructor(videoFile, poseJSONFile, headFile){
    this.videoFile = videoFile;
    this.poseJSONFile = poseJSONFile;
    this.headFile = headFile;

    // media
    this.video = null;
    this.headImg = null;
    this.videoReady = false;

    // json & parsed frames
    this.rawJSON = null;
    this.frameEntries = [];         // normalized sorted by frame_id
    this.poseMap = new Map();
    this.jsonReady = false;
    this.anyDrawReady = false;

    // playback/time
    this.t = 0;
    this.playing = false;
    this.rate = 1;

    // view / overlay
    this.scaleCycle = [1,0.75,0.5,0.25];
    this.scaleIdx = 0; this.scale = this.scaleCycle[this.scaleIdx];
    this.pointSizes = [6,12,18,24,36];
    this.ptIdx = 1; this.ptSize = this.pointSizes[this.ptIdx];
    this.offset = { x:0, y:0 };
    this.drag = { on:false, dx:0, dy:0 };
    this.showLabels = false;
    this.alpha = 200;

    // rose control
    this.roseEmoji = 'ðŸŒ¹';
    this.roseScale = 5;
    this.roseBasePx = 24;
    this.roseYOffset = 0.5;
    this.roseKeypoint = 10;
    this.roseOnAll = false;

    // connector / comparison features
    this.showVideo = true;
    this.connectAll = false;
    this.pairA = [1,2];
    this.pairB = [3,4];
    this.similarity = { avgAngleDeg: null, avgLenRatio: null, validCount: 0, similarityPct: null };

    // trails
    this.trails = {};
    this.showTrails = true;
    this.maxTrail = 240;
    this.trailAlpha = 160;
    this.trailWeight = 3;
    this.trailColors = [[0,200,255],[255,80,0],[0,255,120],[255,200,0],[180,120,255],[255,0,180]];
    this.trailSkip = 1;

    // caches
    this._vw = 0; this._vh = 0; this._scaleX = 1; this._scaleY = 1;
    this._lastPoseFrame = -1;

    // UI
    this.ui = new UI();
    this.param = { speed:1.0, alpha:this.alpha, tlen:this.maxTrail, twidth:this.trailWeight, start:0.0, dur:2.0 };

    // autoplay-safe init
    this.inited = false;
    this.initBtn = new UIButton(width/2 - 100, height/2 - 32, 200, 'Start / Init', ()=>this._userInit());
  }

  preload(){
    loadJSON(this.poseJSONFile, (data) => {
      this.rawJSON = data;
      const entries = Array.isArray(data) ? data : Object.values(data);
      this.frameEntries = [];
      for (let i = 0; i < entries.length; i++){
        const e = entries[i];
        const fid = Number(e.frame_id ?? e.frameId ?? e.frame);
        if (!Number.isFinite(fid)) continue;
        let persons = e.persons ?? e.keypoints ?? e.kpts;
        if (!persons) continue;
        if (!(Array.isArray(persons) && persons.length && Array.isArray(persons[0]) && Array.isArray(persons[0][0]))){
          persons = [persons];
        }
        const personsNorm = persons.map(ps => ps.map(p => p ? p : null));
        this.frameEntries.push({ frame_id: fid, persons: personsNorm, rawEntry: e });
        this.poseMap.set(fid, personsNorm);
        this._lastPoseFrame = max(this._lastPoseFrame, fid);
      }
      this.frameEntries.sort((a,b)=>a.frame_id - b.frame_id);
      this.jsonReady = true;
      this.anyDrawReady = true;
      console.log('Loaded JSON, frames:', this.frameEntries.length, 'lastFrame=', this._lastPoseFrame);
    }, (err)=>{
      console.warn('Failed to load JSON:', err);
      this.rawJSON = null;
      this.jsonReady = false;
      this.anyDrawReady = false;
    });

    this.headImg = loadImage(this.headFile, ()=>{}, ()=>{ this.headImg = null; });
  }

  setup(){
    this.video = createVideo([this.videoFile], ()=>{
      this.video.hide();
      this.video.elt.muted = true;
      this.video.elt.playsInline = true;
      this.video.volume = 0;
      this.video.speed(this.rate);
      this.videoReady = true;
      console.log('Video element created (may still fail to load file).');
    }, (err)=>{
      console.warn('Video load failed:', err);
      this.videoReady = false;
    });

    this._buildUI();
  }

  _userInit(){
    this.inited = true;
    if (this.video && this.videoReady){
      try { this.video.loop(); this.video.speed(this.rate); } catch(e){}
    }
    this.playing = true;
  }

  tick(){
    background(18);

    if (!this.anyDrawReady){
      this._drawStatus('Waiting for pose JSONâ€¦ Add "simbuu.json" to the project.');
      this.initBtn.draw();
      this.ui.draw();
      return;
    }

    if (this.playing){
      this.t += (deltaTime / 1000) * this.rate;
      if (this.video && this.videoReady){
        try {
          const vt = this.video.time();
          if (Math.abs(vt - this.t) > 0.1) this.t = vt;
          else this.video.time(this.t);
        } catch(e){}
      }
    }

    const aspect = POSE_W / POSE_H;
    this._vh = height;
    this._vw = this._vh * aspect;
    this._scaleX = this._vw / POSE_W;
    this._scaleY = this._vh / POSE_H;

    // video
    if (this.showVideo && this.video && this.videoReady && this.inited){
      image(this.video, 0, 0, this._vw, this._vh);
    } else {
      push(); noStroke(); fill(30); rect(0,0,this._vw,this._vh);
      fill(160); textAlign(CENTER,CENTER); textSize(16);
      text(this.videoReady ? 'Click "Start / Init" to play video' : 'No video â€” running in no-video mode', this._vw/2, this._vh/2);
      pop();
    }

    // trails and overlay
    if (this.showTrails) this._drawTrails();
    this._drawPose();

    // compute & draw similarity
    this._computeSimilarity();
    this._drawSimilarityOverlay();

    if (this.videoReady && !this.inited) this.initBtn.draw();

    this.ui.draw();
  }

  _drawStatus(msg){ push(); fill(255); textAlign(CENTER,CENTER); textSize(18); text(msg, width/2, height/2 - 60); pop(); }

  _getDesiredFrameForTime(){ return Math.round(this.t * FPS); }

  _findEntryForFrame(frameNum){
    const arr = this.frameEntries;
    if (!arr.length) return null;
    let lo = 0, hi = arr.length - 1, best = null;
    while (lo <= hi){
      const mid = (lo + hi) >> 1;
      const fid = arr[mid].frame_id;
      if (fid === frameNum){ best = arr[mid]; break; }
      if (fid < frameNum){ best = arr[mid]; lo = mid + 1; }
      else { hi = mid - 1; }
    }
    return best || arr[0];
  }

  _getCurrentPersons(){
    const desired = this._getDesiredFrameForTime();
    const entry = this._findEntryForFrame(desired);
    return entry ? entry.persons : [];
  }

  _drawPose(){
    const persons = this._getCurrentPersons();
    const roseSize = this.roseBasePx * this.roseScale;
    const yOff = this.ptSize * this.roseYOffset;
    const lblSize = max(10, 14 / this.scale);

    push();
    translate(this.offset.x, this.offset.y);
    scale(this.scale);

    // bones
    stroke(255,255,0,this.alpha); strokeWeight(max(3, 4/this.scale)); noFill();
    for (let pi = 0; pi < persons.length; pi++){
      const k = persons[pi];
      for (let e = 0; e < EDGES.length; e++){
        const a = k[EDGES[e][0]], b = k[EDGES[e][1]];
        if (!a || !b) continue;
        line(a[0] * this._scaleX, a[1] * this._scaleY, b[0] * this._scaleX, b[1] * this._scaleY);
      }
    }

    // connect all (polyline through all present keypoints)
    if (this.connectAll){
      for (let pi = 0; pi < persons.length; pi++){
        const k = persons[pi];
        strokeWeight(max(1, 2/this.scale));
        const c = this.trailColors[pi % this.trailColors.length];
        stroke(c[0], c[1], c[2], max(90,this.alpha/1.2));
        noFill();
        beginShape();
        for (let i = 0; i < k.length; i++){
          const pt = k[i];
          if (!pt) continue;
          vertex(pt[0] * this._scaleX, pt[1] * this._scaleY);
        }
        endShape();
      }
    }

    // joints + pair lines + rose
    for (let pi = 0; pi < persons.length; pi++){
      const k = persons[pi];
      const c = this.trailColors[pi % this.trailColors.length];
      noStroke(); fill(c[0], c[1], c[2], this.alpha);
      for (let i = 0; i < k.length; i++){
        const pt = k[i];
        if (!pt) continue;
        const x = pt[0] * this._scaleX, y = pt[1] * this._scaleY;
        ellipse(x, y, this.ptSize);
        if (this.showLabels){
          fill(255,255,255, max(90, this.alpha - 30));
          textSize(lblSize); text(i.toString(), x, y - this.ptSize);
          fill(c[0], c[1], c[2], this.alpha);
        }
        if (i === 0 && this.headImg){
          push(); imageMode(CENTER); tint(255, this.alpha);
          const hs = 100 * this.scale; image(this.headImg, x, y - hs/2, hs, hs); pop();
        }
      }

      // draw pair A and B
      const a0 = k[this.pairA[0]], a1 = k[this.pairA[1]];
      const b0 = k[this.pairB[0]], b1 = k[this.pairB[1]];
      strokeWeight(max(2, 3/this.scale));
      if (a0 && a1){
        stroke(0,200,255,220); line(a0[0]*this._scaleX, a0[1]*this._scaleY, a1[0]*this._scaleX, a1[1]*this._scaleY);
        noStroke(); fill(0,200,255,220); ellipse(a0[0]*this._scaleX, a0[1]*this._scaleY, this.ptSize/1.2); ellipse(a1[0]*this._scaleX, a1[1]*this._scaleY, this.ptSize/1.2);
      }
      if (b0 && b1){
        stroke(255,140,50,220); line(b0[0]*this._scaleX, b0[1]*this._scaleY, b1[0]*this._scaleX, b1[1]*this._scaleY);
        noStroke(); fill(255,140,50,220); ellipse(b0[0]*this._scaleX, b0[1]*this._scaleY, this.ptSize/1.2); ellipse(b1[0]*this._scaleX, b1[1]*this._scaleY, this.ptSize/1.2);
      }

      // rose
      if (this.roseOnAll){
        const kp = k[this.roseKeypoint];
        if (kp){
          const rx = kp[0] * this._scaleX, ry = kp[1] * this._scaleY;
          push(); textAlign(CENTER, CENTER); textSize(this.roseBasePx * this.roseScale); fill(255,255,255,this.alpha);
          text(this.roseEmoji, rx, ry - (this.ptSize * this.roseYOffset)); pop();
        }
      }
    }

    pop();

    // update trails using nearest entry
    const desired = this._getDesiredFrameForTime();
    const entry = this._findEntryForFrame(desired);
    const entryPersons = entry ? entry.persons : [];
    this._updateTrails(entry ? entry.frame_id : desired, entryPersons);
  }

  _computeSimilarity(){
    // compute similarity for current nearest entry and store
    const desired = this._getDesiredFrameForTime();
    const entry = this._findEntryForFrame(desired);
    if (!entry){ this.similarity = { avgAngleDeg: null, avgLenRatio: null, validCount: 0, similarityPct: null }; return; }
    const persons = entry.persons;
    let angles = [], ratios = [], valid = 0;
    for (let p = 0; p < persons.length; p++){
      const k = persons[p];
      const a0 = k[this.pairA[0]], a1 = k[this.pairA[1]];
      const b0 = k[this.pairB[0]], b1 = k[this.pairB[1]];
      if (!a0 || !a1 || !b0 || !b1) continue;
      const vA = [a1[0]-a0[0], a1[1]-a0[1]];
      const vB = [b1[0]-b0[0], b1[1]-b0[1]];
      const na = Math.hypot(vA[0], vA[1]); const nb = Math.hypot(vB[0], vB[1]);
      if (na < 1e-6 || nb < 1e-6) continue;
      const dot = vA[0]*vB[0] + vA[1]*vB[1];
      const cosv = constrain(dot / (na*nb), -1, 1);
      const angle = Math.acos(cosv) * (180/Math.PI);
      angles.push(angle); ratios.push(na/nb); valid++;
    }
    if (valid === 0) { this.similarity = { avgAngleDeg: null, avgLenRatio: null, validCount: 0, similarityPct: null }; return; }
    const avgAngle = angles.reduce((s,v)=>s+v,0)/angles.length;
    const avgRatio = ratios.reduce((s,v)=>s+v,0)/ratios.length;
    // compute percentage (100 best)
    const angleSim = max(0, 1 - (avgAngle / 180)) * 100; // 0..100
    const ratioDiff = Math.min(Math.abs(1 - avgRatio), 1); // clamp diff to 1
    const ratioSim = max(0, 1 - ratioDiff) * 100; // 0..100
    const combined = (angleSim + ratioSim) / 2;
    this.similarity = { avgAngleDeg: avgAngle, avgLenRatio: avgRatio, validCount: valid, similarityPct: combined };
  }

  _drawSimilarityOverlay(){
    push();
    const pad = 10;
    const x = 8, y = 8;
    fill(0,0,0,160); rect(x, y, 320, 96, 6);
    fill(220); textAlign(LEFT, TOP); textSize(12);
    text(`Frame (approx): ${this._getDesiredFrameForTime()}`, x + pad, y + pad);
    text(`Pair A: ${this.pairA[0]} -> ${this.pairA[1]}`, x + pad, y + pad + 16);
    text(`Pair B: ${this.pairB[0]} -> ${this.pairB[1]}`, x + pad, y + pad + 32);
    if (this.similarity.validCount === 0){
      fill(200); text('No valid persons with both pairs', x + pad, y + pad + 50);
    } else {
      fill(180,255,180); text(`Avg angle: ${this.similarity.avgAngleDeg.toFixed(1)}Â°`, x + pad, y + pad + 50);
      fill(200,220); text(`Avg len ratio A/B: ${this.similarity.avgLenRatio.toFixed(2)} (n=${this.similarity.validCount})`, x + pad, y + pad + 68);
      fill(255,220,180); text(`Similarity: ${this.similarity.similarityPct.toFixed(1)}%`, x + pad + 180, y + pad + 68);
    }
    pop();
  }

  _updateTrails(frameIndex, persons){
    if ((frameIndex % this.trailSkip) !== 0) return;
    for (let pi = 0; pi < persons.length; pi++){
      if (!this.trails[pi]) this.trails[pi] = {};
      const k = persons[pi];
      for (let ki = 0; ki < k.length; ki++){
        const p = k[ki]; if (!p) continue;
        const arr = (this.trails[pi][ki] ||= []);
        arr.push({x: p[0], y: p[1]});
        if (arr.length > this.maxTrail) arr.shift();
      }
    }
  }

  _drawTrails(){
    push(); translate(this.offset.x, this.offset.y); scale(this.scale);
    const baseW = max(1.25, this.trailWeight / this.scale);
    for (const piStr in this.trails){
      const pi = Number(piStr);
      const [r,g,b] = this.trailColors[pi % this.trailColors.length];
      const parts = this.trails[pi];
      for (const kiStr in parts){
        const pts = parts[kiStr];
        if (!pts || pts.length < 2) continue;
        strokeWeight(baseW);
        for (let s = 1; s < pts.length; s++){
          const a = lerp(40, this.trailAlpha, s / pts.length);
          stroke(r, g, b, a);
          const p1 = pts[s-1], p2 = pts[s];
          line(p1.x * this._scaleX, p1.y * this._scaleY, p2.x * this._scaleX, p2.y * this._scaleY);
        }
      }
    }
    pop();
  }

  // ---------------- interaction ----------------
  onKey(k){
    if (k === 'T') this.showTrails = !this.showTrails;
    if (k === 'P') (this.playing ? this.pause() : this.play());
    if (k === 'L') this.showLabels = !this.showLabels;
    if (k === 'C') this.trails = {};
    if (k === 'S') { this.param.start = +((this.t||0).toFixed(2)); this.ui.syncFrom(this); }
  }

  onMousePressed(){
    if (this.initBtn.contains(mouseX, mouseY)){ this.initBtn.mousePressed(); return; }
    if (this.ui.mousePressed()) return;
    this.drag.on = true;
    this.drag.dx = mouseX - this.offset.x;
    this.drag.dy = mouseY - this.offset.y;
  }

  onMouseDragged(){ if (!this.drag.on) return; this.offset.x = mouseX - this.drag.dx; this.offset.y = mouseY - this.drag.dy; }
  onMouseReleased(){ if (this.initBtn.down) this.initBtn.mouseReleased(); if (this.ui.mouseReleased()) return; this.drag.on = false; }

  _jumpToFrame(frameId){
    this.t = frameId / FPS;
    if (this.video && this.videoReady){
      try { this.video.time(this.t); } catch(e){}
    }
  }

  play(){ this.playing = true; if (this.video && this.videoReady) try { this.video.play(); this.video.speed(this.rate); } catch(e){} }
  pause(){ this.playing = false; if (this.video) try { this.video.pause(); } catch(e){} }
  stop(){ this.playing = false; this.t = 0; if (this.video) try { this.video.pause(); this.video.time(0); } catch(e){} }

  // ---------------- CSV Export ----------------
  _computeSimilarityForEntry(entry){
    // returns { avgAngleDeg, avgLenRatio, validCount, similarityPct }
    if (!entry) return { avgAngleDeg: null, avgLenRatio: null, validCount: 0, similarityPct: null };
    const persons = entry.persons;
    let angles = [], ratios = [], valid = 0;
    for (let p = 0; p < persons.length; p++){
      const k = persons[p];
      const a0 = k[this.pairA[0]], a1 = k[this.pairA[1]];
      const b0 = k[this.pairB[0]], b1 = k[this.pairB[1]];
      if (!a0 || !a1 || !b0 || !b1) continue;
      const vA = [a1[0]-a0[0], a1[1]-a0[1]];
      const vB = [b1[0]-b0[0], b1[1]-b0[1]];
      const na = Math.hypot(vA[0], vA[1]); const nb = Math.hypot(vB[0], vB[1]);
      if (na < 1e-6 || nb < 1e-6) continue;
      const dot = vA[0]*vB[0] + vA[1]*vB[1];
      const cosv = constrain(dot / (na*nb), -1, 1);
      const angle = Math.acos(cosv) * (180/Math.PI);
      angles.push(angle); ratios.push(na/nb); valid++;
    }
    if (valid === 0) return { avgAngleDeg: null, avgLenRatio: null, validCount: 0, similarityPct: null };
    const avgAngle = angles.reduce((s,v)=>s+v,0)/angles.length;
    const avgRatio = ratios.reduce((s,v)=>s+v,0)/ratios.length;
    const angleSim = max(0, 1 - (avgAngle / 180)) * 100;
    const ratioDiff = Math.min(Math.abs(1 - avgRatio), 1);
    const ratioSim = max(0, 1 - ratioDiff) * 100;
    const combined = (angleSim + ratioSim) / 2;
    return { avgAngleDeg: avgAngle, avgLenRatio: avgRatio, validCount: valid, similarityPct: combined };
  }

  saveCSV(startSec=0, durationSec=2){
    if (!this.jsonReady) return;
    startSec = max(0, Number(startSec) || 0);
    durationSec = max(0, Number(durationSec) || 0.001);
    const startF = max(0, floor(startSec * FPS));
    const endFExcl = min(floor((startSec + durationSec) * FPS), this._lastPoseFrame + 1);
    const lines = [];
    // header
    lines.push('frame_id,time_sec,avg_angle_deg,avg_len_ratio,similarity_pct,valid_count');
    for (let f = startF; f < endFExcl; f++){
      const entry = this._findEntryForFrame(f);
      const sim = this._computeSimilarityForEntry(entry);
      const timeSec = ((f - startF) / FPS).toFixed(3);
      const a = (sim.avgAngleDeg === null) ? '' : sim.avgAngleDeg.toFixed(3);
      const r = (sim.avgLenRatio === null) ? '' : sim.avgLenRatio.toFixed(3);
      const sp = (sim.similarityPct === null) ? '' : sim.similarityPct.toFixed(3);
      const vc = sim.validCount || 0;
      lines.push(`${f},${timeSec},${a},${r},${sp},${vc}`);
    }
    const s0 = (startSec).toFixed(2), s1 = (durationSec).toFixed(2);
    saveStrings(lines, `pose_similarity_${s0}-${s1}s.csv`);
  }

  saveWindowJSON(startSec = 0, durationSec = 2){
    // keep JSON exporter (unchanged)
    if (!this.jsonReady) return;
    startSec = max(0, Number(startSec) || 0);
    durationSec = max(0, Number(durationSec) || 0);
    const startF = max(0, floor(startSec * FPS));
    const endFExcl = min(floor((startSec + durationSec) * FPS), this._lastPoseFrame + 1);
    const out = [];
    for (let f = startF; f < endFExcl; f++){
      const persons = this.poseMap.get(f) || [];
      const personsCopy = persons.map(kpts => kpts.map(p => (p ? [p[0], p[1], p[2] ?? 1] : null)));
      out.push({ frame_id: f, time_sec: +( (f - startF) / FPS ).toFixed(3), persons: personsCopy });
    }
    saveJSON(out, `pose_segment_${startF}-${endFExcl-1}.json`);
  }

  // build bottom UI (no JSON inspector controls)
  _buildUI(){
    const y = height - 140;
    const row = (i)=> y + i * 36;
    const right = width - 12;

    this.ui.add(new UIButton(12, row(0), 64, 'Play', ()=>this.play()));
    this.ui.add(new UIButton(80, row(0), 64, 'Pause', ()=>this.pause()));
    this.ui.add(new UIButton(148,row(0),64,'Stop', ()=>this.stop()));
    this.ui.add(new UIButton(216,row(0),72,'Scale', ()=>{
      this.scaleIdx = (this.scaleIdx + 1) % this.scaleCycle.length;
      this.scale = this.scaleCycle[this.scaleIdx];
      this.ptIdx = (this.ptIdx + 1) % this.pointSizes.length;
      this.ptSize = this.pointSizes[this.ptIdx];
    }));
    this.ui.add(new UIButton(294,row(0),120,'Toggle Trails', ()=> this.showTrails = !this.showTrails));
    this.ui.add(new UIButton(420,row(0),120,'Clear Trails', ()=> { this.trails = {}; }));

    // video toggle + connect toggle
    this.ui.add(new UIButton(right - 78, row(0), 66, 'Video', ()=>{ this.showVideo = !this.showVideo; }));
    this.ui.add(new UIButton(right - 160, row(0), 72, 'Connect All', ()=>{ this.connectAll = !this.connectAll; }));

    // rose toggle
    const roseBtn = new UIButton(right - 260, row(0), 120, `Rose:${this.roseKeypoint}`, ()=>{
      this.roseOnAll = !this.roseOnAll;
      roseBtn.label = this.roseOnAll ? `RoseOnAll` : `Rose:${this.roseKeypoint}`;
    });
    this.roseToggleButton = roseBtn;
    this.ui.add(roseBtn);

    // row 1 sliders
    this.ui.add(new UILabel(12,row(1),'Speed'));
    this.ui.add(new UISlider(70,row(1),200,0.25,2.0,this.param.speed,0.01,(v)=>{ this.param.speed=v; this.rate=v; if(this.video) this.video.speed(v); }));
    this.ui.add(new UILabel(280,row(1),'Alpha'));
    this.ui.add(new UISlider(336,row(1),200,0,255,this.param.alpha,1,(v)=>{ this.param.alpha=v; this.alpha=v|0; }));
    this.ui.add(new UILabel(560,row(1),'Trail Len'));
    this.ui.add(new UISlider(620,row(1),220,10,600,this.param.tlen,1,(v)=>{ this.param.tlen=v|0; this.maxTrail=v|0; }));
    this.ui.add(new UILabel(848,row(1),'Thick'));
    this.ui.add(new UISlider(898,row(1),150,1,8,this.param.twidth,0.5,(v)=>{ this.param.twidth=v; this.trailWeight=v; }));

    // row 2: steppers for pair A and pair B, Start/Export
    this.ui.add(new UILabel(12,row(2),'Pair A'));
    const a0 = new UIStepper(76,row(2),60,this.pairA[0],1,0,99,(v)=>{ this.pairA[0] = Math.max(0, Math.round(v)); });
    const a1 = new UIStepper(140,row(2),60,this.pairA[1],1,0,99,(v)=>{ this.pairA[1] = Math.max(0, Math.round(v)); });
    this.ui.add(a0); this.ui.add(a1);

    this.ui.add(new UILabel(220,row(2),'Pair B'));
    const b0 = new UIStepper(280,row(2),60,this.pairB[0],1,0,99,(v)=>{ this.pairB[0] = Math.max(0, Math.round(v)); });
    const b1 = new UIStepper(344,row(2),60,this.pairB[1],1,0,99,(v)=>{ this.pairB[1] = Math.max(0, Math.round(v)); });
    this.ui.add(b0); this.ui.add(b1);

    // Start=Now + export controls
    this.ui.add(new UIButton(420,row(2),110,'â†˜ Start=Now', ()=>{ this.param.start = +((this.t||0).toFixed(2)); this.ui.syncFrom(this); }));
    this.ui.add(new UIButton(right-420,row(2),120,'Save 0â€“2s JSON', ()=> this.saveWindowJSON(0,2)));
    this.ui.add(new UIButton(right-294,row(2),120,'Save 0â€“5s JSON', ()=> this.saveWindowJSON(0,5)));
    this.ui.add(new UIButton(right-168,row(2),156,'Save Range JSON', ()=> this.saveWindowJSON(this.param.start, this.param.dur)));

    // EXPORT CSV (similarity timeline)
    this.ui.add(new UIButton(right-168,row(0),156,'Export CSV', ()=> this.saveCSV(this.param.start, this.param.dur)));
  }
}


// ---------------- Canvas UI primitives (unchanged) ----------------
class UI { constructor(){ this.items=[]; this._active=null; } add(w){ this.items.push(w); w.ui=this; return w; } draw(){ for(const w of this.items) w.draw(); } mousePressed(){ for(let i=this.items.length-1;i>=0;i--){ const w=this.items[i]; if(w.mousePressed && w.contains(mouseX,mouseY)){ this._active=w; w.mousePressed(); return true; } } return false; } mouseDragged(){ if(this._active && this._active.mouseDragged) this._active.mouseDragged(); } mouseReleased(){ if(this._active && this._active.mouseReleased) this._active.mouseReleased(); this._active=null; return true; } syncFrom(app){ for(const w of this.items) if(w.syncFrom) w.syncFrom(app); } }

class UILabel { constructor(x,y,text){ this.x=x; this.y=y; this.text=text; this.h=24; } contains(){ return false; } draw(){ push(); noStroke(); fill(220); textSize(14); textAlign(LEFT,CENTER); text(this.text,this.x,this.y+12); pop(); } }

class UIButton {
  constructor(x,y,w,label,onClick){ this.x=x; this.y=y; this.w=w; this.h=28; this.label=label; this.onClick=onClick; this.down=false; }
  contains(px,py){ return px>=this.x && px<=this.x+this.w && py>=this.y && py<=this.y+this.h; }
  draw(){ const hover=this.contains(mouseX,mouseY); push(); noStroke(); fill(this.down?30:(hover?50:35)); rect(this.x,this.y,this.w,this.h,8); stroke(255,140); noFill(); rect(this.x,this.y,this.w,this.h,8); noStroke(); fill(255); textAlign(CENTER,CENTER); textSize(13); text(this.label,this.x+this.w/2,this.y+this.h/2); pop(); }
  mousePressed(){ this.down=true; }
  mouseReleased(){ if(this.down && this.contains(mouseX,mouseY) && this.onClick) this.onClick(); this.down=false; }
}

class UISlider {
  constructor(x,y,w,min,max,value,step,onChange){ this.x=x; this.y=y; this.w=w; this.h=24; this.min=min; this.max=max; this.value=value; this.step=step||0.01; this.onChange=onChange; this.grab=false; }
  contains(px,py){ return px>=this.x && px<=this.x+this.w && py>=this.y && py<=this.y+this.h; }
  _valToX(v){ return this.x + (this.w - 1) * ((v - this.min) / (this.max - this.min)); }
  _xToVal(px){ const t = constrain((px - this.x) / (this.w - 1), 0, 1); const v = this.min + t * (this.max - this.min); if (this.step > 0) return Math.round(v / this.step) * this.step; return v; }
  draw(){ push(); stroke(120); strokeWeight(2); line(this.x,this.y+this.h/2,this.x+this.w,this.y+this.h/2); const kx = this._valToX(this.value); noStroke(); fill(230); circle(kx, this.y+this.h/2, 12); noStroke(); fill(220); textAlign(LEFT,CENTER); textSize(12); text(this.value.toFixed((this.step>=1)?0:(this.step>=0.1?1:2)), this.x+this.w+8, this.y+this.h/2); pop(); }
  mousePressed(){ this.grab = true; this.value = this._xToVal(mouseX); if (this.onChange) this.onChange(this.value); }
  mouseDragged(){ if (!this.grab) return; this.value = this._xToVal(mouseX); if (this.onChange) this.onChange(this.value); }
  mouseReleased(){ this.grab = false; }
  syncFrom(){}
}

class UIStepper {
  constructor(x,y,w,value,step,min,max,onChange){ this.x=x; this.y=y; this.w=w; this.h=28; this.value=value; this.step=step||1; this.min=min??-Infinity; this.max=max??Infinity; this.onChange=onChange; this.btnW=28; this._dec=new UIButton(x,y,this.btnW,'â€“',()=>this._bump(-1)); this._inc=new UIButton(x+w-this.btnW,y,this.btnW,'+',()=>this._bump(+1)); }
  _bump(dir){ let v = this.value + dir * this.step; v = constrain(v, this.min, this.max); this.value = v; if (this.onChange) this.onChange(this.value); }
  contains(px,py){ return px>=this.x && px<=this.x+this.w && py>=this.y && py<=this.y+this.h; }
  draw(){ push(); noFill(); stroke(180,140); rect(this.x,this.y,this.w,this.h,6); noStroke(); fill(240); textAlign(CENTER,CENTER); textSize(13); text(this.value.toFixed(0), this.x+this.w/2, this.y+this.h/2); pop(); this._dec.draw(); this._inc.draw(); }
  mousePressed(){ if (this._dec.contains(mouseX,mouseY)) this._dec.mousePressed(); else if (this._inc.contains(mouseX,mouseY)) this._inc.mousePressed(); }
  mouseDragged(){}
  mouseReleased(){ if(this._dec.down) this._dec.mouseReleased(); if(this._inc.down) this._inc.mouseReleased(); }
  syncFrom(app){ const s=(this.onChange&&this.onChange.toString())||''; if (s.includes('param.start')) this.value = app.param.start; if (s.includes('param.dur')) this.value = app.param.dur; }
}
