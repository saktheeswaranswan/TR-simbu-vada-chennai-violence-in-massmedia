// fast_pose_refactor.js
// OOP-friendly p5.js pose + video overlay sketch
// Paste into editor.p5js.org. Add your pose JSON and optional head image/video files.

const FPS = 30;
const POSE_W = 640, POSE_H = 480;
const EDGES = [
  [5,7],[7,9],[6,8],[8,10],
  [11,13],[13,15],[12,14],[14,16],
  [5,6],[11,12],[5,11],[6,12]
];

// NOTE: no Gloriosa-lily emoji. Using ðŸŒº (hibiscus) and ðŸŒ¹ (rose) as substitutes.
const GLORIOSA_EMOJI = 'ðŸŒº';
const ROSE_EMOJI = 'ðŸŒ¹';

let app;

function preload(){
  app = new App({ videoFile: 'Hghdugfy.mp4', poseJSONFile: 'simbuu.json', headFile: 'head.png' });
  app.preload();
}
function setup(){ createCanvas(1280,720); frameRate(FPS); app.setup(); }
function draw(){ background(12); app.tick(); }
function mousePressed(){ app.onMousePressed(); }
function mouseDragged(){ app.onMouseDragged(); }
function mouseReleased(){ app.onMouseReleased(); }
function keyPressed(){ app.onKey(key.toUpperCase()); }
function mouseWheel(evt) { if (app && app.ui && app.ui.jsonOpen) { app.ui.scrollJSON(evt.deltaY>0?3:-3); return false; } return true; }

// ------------------------- Utilities -------------------------
function avgPoint(points){ if(!points||!points.length) return null; let sx=0, sy=0, n=0; for(const p of points){ if(!p) continue; sx+=p[0]; sy+=p[1]; n++; } return n? [sx/n, sy/n] : null; }
function dist2(a,b){ const dx=(a[0]-b[0]); const dy=(a[1]-b[1]); return dx*dx+dy*dy; }
function clampStr(s, maxLen=120){ if(!s) return ''; if(s.length<=maxLen) return s; return s.slice(0,maxLen-3)+'...'; }

// format keypoints array for on-canvas display; shows x,y (rounded) and optional score
function formatKptsArray(kpts, limit=6, showScore=false){
  if(!kpts) return '[]';
  const arr = [];
  for(let i=0;i<Math.min(limit, kpts.length); i++){
    const p = kpts[i];
    if(!p) arr.push('null');
    else {
      const x = Math.round(p[0]);
      const y = Math.round(p[1]);
      if(showScore && p.length>=3) arr.push(`[${x},${y},${p[2].toFixed(2)}]`);
      else arr.push(`[${x},${y}]`);
    }
  }
  if(kpts.length>limit) arr.push('...');
  return '['+arr.join(', ')+']';
}

// ------------------------- PoseLoader -------------------------
class PoseLoader {
  constructor(jsonPath){ this.jsonPath = jsonPath; this.poseMap = new Map(); this.lastFrame = 0; this.ready = false; }

  preload(done){
    if(!this.jsonPath){ this.ready=false; done && done(); return; }
    loadJSON(this.jsonPath, (data)=>{
      this._parseRaw(data);
      this.ready = true; done && done();
    }, (err)=>{ console.warn('Pose JSON load failed', err); this.ready=false; done && done(); });
  }

  _parseRaw(data){
    this.poseMap.clear();
    const arr = Array.isArray(data)? data : Object.values(data);
    for(let i=0;i<arr.length;i++){
      const e = arr[i];
      const fid = Number(e.frame_id ?? e.frameId ?? e.frame ?? e.f ?? i);
      if(!Number.isFinite(fid)) continue;
      let persons = e.persons ?? e.keypoints ?? e.kpts ?? e.people ?? e.poses;
      if(!persons) continue;

      // normalize many common formats into array-of-persons where each person is [[x,y,score?], ...]
      if(Array.isArray(persons) && persons.length && typeof persons[0] === 'number'){
        // flat single-person array
        persons = [ this._flattenToKpts(persons) ];
      } else if(Array.isArray(persons) && persons.length && Array.isArray(persons[0]) && typeof persons[0][0] === 'number'){
        // array-of-persons: each person may be flat or already array-of-points
        persons = persons.map(p => Array.isArray(p[0]) ? this._ensureKpts(p) : this._flattenToKpts(p));
      } else if(Array.isArray(persons) && typeof persons[0] === 'object'){
        // COCO-style objects
        persons = persons.map(p => this._ensureKpts(p.keypoints ?? p.kpts ?? p));
      } else {
        try{ persons = persons.map(p=>this._ensureKpts(p)); }catch(e){ continue; }
      }

      this.poseMap.set(fid, persons);
      if(fid > this.lastFrame) this.lastFrame = fid;
    }
  }

  _flattenToKpts(flat){
    const k = [];
    for(let i=0;i<flat.length;){
      const x = Number(flat[i++]); if(isNaN(x)){ k.push(null); continue; }
      const y = Number(flat[i++]); if(isNaN(y)){ k.push(null); continue; }
      const maybe = flat[i];
      if(maybe!==undefined && typeof maybe === 'number' && maybe<=1.0){ k.push([x,y,maybe]); i++; }
      else k.push([x,y,1.0]);
    }
    return k;
  }

  _ensureKpts(p){
    if(!p) return [];
    if(Array.isArray(p) && typeof p[0] === 'number'){
      if(p.length % 3 === 0){ const out=[]; for(let i=0;i<p.length;i+=3) out.push([p[i],p[i+1],p[i+2]]); return out; }
      if(p.length % 2 === 0){ const out=[]; for(let i=0;i<p.length;i+=2) out.push([p[i],p[i+1],1.0]); return out; }
    }
    if(Array.isArray(p) && Array.isArray(p[0])) return p.map(q=> q? [q[0],q[1], q[2] ?? 1.0] : null);
    return [];
  }

  // remove near-duplicate persons in same frame
  dedupeFrames(thresholdPx=8){
    const t2 = thresholdPx*thresholdPx;
    for(const [f, persons] of this.poseMap){
      if(!persons || persons.length<2) continue;
      const keep = [];
      const centroids = persons.map(p=> avgPoint(p));
      for(let i=0;i<persons.length;i++){
        if(!centroids[i]){ keep.push(persons[i]); continue; }
        let duplicate=false;
        for(let j=0;j<keep.length;j++){
          const c = avgPoint(keep[j]); if(!c) continue; if(dist2(c, centroids[i]) <= t2){ duplicate=true; break; }
        }
        if(!duplicate) keep.push(persons[i]);
      }
      this.poseMap.set(f, keep);
    }
  }
}

// ------------------------- UI primitives -------------------------
class UIElement { constructor(x,y,w,h){ this.x=x; this.y=y; this.w=w; this.h=h; this.ui=null; } contains(px,py){ return px>=this.x && px<=this.x+this.w && py>=this.y && py<=this.y+this.h; } draw(){} mousePressed(){} mouseDragged(){} mouseReleased(){} }
class UIButton extends UIElement{ constructor(x,y,w,label,onClick){ super(x,y,w,28); this.label=label; this.onClick=onClick; this.down=false; } draw(){ const hover=this.contains(mouseX,mouseY); push(); noStroke(); fill(this.down?30:(hover?50:35)); rect(this.x,this.y,this.w,this.h,8); stroke(255,140); noFill(); rect(this.x,this.y,this.w,this.h,8); noStroke(); fill(255); textAlign(CENTER,CENTER); textSize(13); text(this.label,this.x+this.w/2,this.y+this.h/2); pop(); } mousePressed(){ this.down=true; } mouseReleased(){ if(this.down && this.contains(mouseX,mouseY) && this.onClick) this.onClick(); this.down=false; } }
class UILabel extends UIElement{ constructor(x,y,text){ super(x,y,200,24); this.text=text; } draw(){ push(); noStroke(); fill(220); textSize(14); textAlign(LEFT,CENTER); text(this.text,this.x,this.y+12); pop(); } }
class UISlider extends UIElement{ constructor(x,y,w,min,max,value,step,onChange){ super(x,y,w,24); this.min=min; this.max=max; this.value=value; this.step=step||0.01; this.onChange=onChange; this.grab=false; } _valToX(v){ return this.x+(this.w-1)*((v-this.min)/(this.max-this.min)); } _xToVal(px){ const t=constrain((px-this.x)/(this.w-1),0,1); const v=this.min+t*(this.max-this.min); return (this.step>0)? Math.round(v/this.step)*this.step : v; } draw(){ push(); stroke(120); strokeWeight(2); line(this.x,this.y+this.h/2,this.x+this.w,this.y+this.h/2); const kx=this._valToX(this.value); noStroke(); fill(230); circle(kx,this.y+this.h/2,12); noStroke(); fill(220); textAlign(LEFT,CENTER); textSize(12); text(this.value.toFixed((this.step>=1)?0:(this.step>=0.1?1:2)), this.x+this.w+8, this.y+this.h/2); pop(); } mousePressed(){ this.grab=true; this.value=this._xToVal(mouseX); if(this.onChange) this.onChange(this.value); } mouseDragged(){ if(!this.grab) return; this.value=this._xToVal(mouseX); if(this.onChange) this.onChange(this.value); } mouseReleased(){ this.grab=false; } }
class UIStepper extends UIElement{ constructor(x,y,w,value,step,min,max,onChange){ super(x,y,w,28); this.value=value; this.step=step||0.1; this.min=min||-Infinity; this.max=max||Infinity; this.onChange=onChange; this.btnW=28; this._dec=new UIButton(x,y,this.btnW,'â€“',()=>this._bump(-1)); this._inc=new UIButton(x+w-this.btnW,y,this.btnW,'+',()=>this._bump(+1)); } _bump(dir){ let v=this.value+dir*this.step; v=constrain(v,this.min,this.max); this.value=v; if(this.onChange) this.onChange(this.value); } draw(){ push(); noFill(); stroke(180,140); rect(this.x,this.y,this.w,this.h,6); noStroke(); fill(240); textAlign(CENTER,CENTER); textSize(13); text(this.value.toFixed(2), this.x+this.w/2, this.y+this.h/2); pop(); this._dec.draw(); this._inc.draw(); } mousePressed(){ if(this._dec.contains(mouseX,mouseY)) this._dec.mousePressed(); else if(this._inc.contains(mouseX,mouseY)) this._inc.mousePressed(); } mouseReleased(){ if(this._dec.down) this._dec.mouseReleased(); if(this._inc.down) this._inc.mouseReleased(); } }
class UICheckbox extends UIElement{ constructor(x,y,label,initial,onToggle){ super(x,y,18,18); this.label=label; this.checked=initial||false; this.onToggle=onToggle; } draw(){ push(); stroke(140); rect(this.x,this.y,this.w,this.h,4); if(this.checked){ push(); translate(this.x+this.w/2,this.y+this.h/2); rotate(-PI/6); strokeWeight(3); line(-6,0,0,6); line(0,6,10,-8); pop(); } noStroke(); fill(220); textSize(13); textAlign(LEFT,CENTER); text(this.label,this.x+this.w+8,this.y+this.h/2); pop(); } mousePressed(){ this.checked = !this.checked; if(this.onToggle) this.onToggle(this.checked); } }
class UITextBox extends UIElement{ constructor(x,y,w,initial,onChange){ super(x,y,w,28); this.value = initial || ''; this.onChange = onChange; } draw(){ push(); noFill(); stroke(160); rect(this.x,this.y,this.w,this.h,6); noStroke(); fill(240); textAlign(LEFT,CENTER); textSize(13); // single-line preview; long text truncated for UI
  const disp = (this.value||'').length>120 ? (this.value||'').slice(0,117)+'...' : (this.value||'');
  text(disp, this.x+8, this.y+this.h/2); pop(); } mousePressed(){ const v = prompt('Pose text (editable). To copy full text use Copy button.', this.value); if(v !== null){ this.value = v; if(this.onChange) this.onChange(v); } } }

// ------------------------- App -------------------------
class App {
  constructor({videoFile, poseJSONFile, headFile} = {}){
    this.videoFile = videoFile; this.poseJSONFile = poseJSONFile; this.headFile = headFile;

    this.video = null; this.headImg = null;
    this.poseLoader = new PoseLoader(this.poseJSONFile);

    this.t = 0; this.playing=false; this.rate=1;

    this.scaleCycle=[1,0.75,0.5,0.25]; this.scaleIdx=0; this.scale=this.scaleCycle[0];
    this.pointSizes=[6,12,18,24,36]; this.ptIdx=1; this.ptSize=this.pointSizes[this.ptIdx];

    this.headSize = 150; this.alpha = 200; this.offset={x:0,y:0}; this.drag={on:false,dx:0,dy:0};

    this.roseScale=1.0; this.roseBasePx=28; this.roseYOffset=0.6;

    this.trails = {}; this.showTrails = true; this.maxTrail = 240; this.trailAlpha = 160; this.trailWeight = 3; this.trailColors = [[0,200,255],[255,80,0],[0,255,120],[255,200,0],[180,120,255],[255,0,180]]; this.trailSkip=1;

    this._vw=0; this._vh=0; this._scaleX=1; this._scaleY=1; this._lastPoseFrame = 0;

    // option: show full pose array (scores) on canvas
    this.showFullPoseOnCanvas = false;

    // Parade (walking array) settings
    this.showParade = false;
    this.paradeCount = 6;
    this.paradeSpeed = 120; // pixels per second
    this.paradeSpacing = 90;
    this.paradeEmoji = ROSE_EMOJI;

    this.ui = new UIManager(this);
    this.inited=false;
  }

  preload(){ this.poseLoader.preload(()=>{ this._lastPoseFrame = this.poseLoader.lastFrame; }); this.headImg = loadImage(this.headFile, ()=>{}, ()=>{ this.headImg=null; }); }

  setup(){ if(this.videoFile){ this.video = createVideo([this.videoFile], ()=>{ this.video.hide(); this.video.elt.muted=true; this.video.elt.playsInline=true; this.video.volume(0); this.video.speed(this.rate); }, (err)=>{ console.warn('Video load failed',err); }); } this.ui.build(); }

  _userInit(){ this.inited=true; if(this.video){ try{ this.video.loop(); this.video.speed(this.rate); }catch(e){} this.playing=true; } }

  tick(){ if(!this.poseLoader.ready){ fill(255); textAlign(CENTER,CENTER); textSize(18); text('Waiting for pose JSONâ€¦', width/2, height/2 - 60); this.ui.draw(); return; }

    if(this.playing && this.video){ this.t += (deltaTime/1000) * this.rate; const vd = this.video?.elt?.duration ?? Infinity; if(this.t>=vd){ this.t = vd; this.pause(); } else if(Math.abs(this.video.time() - this.t) > 0.1) this.video.time(this.t); }

    const aspect = POSE_W / POSE_H; this._vh = height; this._vw = this._vh * aspect; this._scaleX = this._vw / POSE_W; this._scaleY = this._vh / POSE_H;

    // draw video or background
    if(this.video && this.inited && this.video.elt && this.video.elt.readyState >= 2){ image(this.video, 0, 0, this._vw, this._vh); }
    else { push(); noStroke(); fill(30); rect(0,0,this._vw,this._vh); fill(170); textAlign(CENTER,CENTER); textSize(16); text(this.video? 'Click "Start / Init" to play video' : 'No video â€” running in no-video mode', this._vw/2, this._vh/2); pop(); }

    // parade (walkers) under pose overlay if enabled
    if(this.showParade) this._drawParade();

    if(this.showTrails) this._drawTrails();
    this._drawPose();
    this.ui.draw();
  }

  _drawParade(){
    push();
    // Parade should be drawn in screen coords (not pose coords)
    const now = millis()/1000;
    const totalWidth = this._vw + this.paradeSpacing;
    const baseY = this._vh * 0.80;
    textAlign(CENTER,CENTER);
    for(let i=0;i<this.paradeCount;i++){
      // each walker offset by spacing so they are in an "array"
      const offset = (now * this.paradeSpeed + i * this.paradeSpacing) % totalWidth - this.paradeSpacing;
      const x = offset;
      const bob = sin((now*3 + i*0.6)) * 10;
      const y = baseY + bob;
      textSize(this.roseBasePx * 0.9);
      text(this.paradeEmoji, x, y);
      // optional small shadow
      noStroke(); fill(0, 60); ellipse(x, y + (this.roseBasePx*0.4), (this.roseBasePx*0.6), (this.roseBasePx*0.22));
    }
    pop();
  }

  _drawPose(){
    const frameIndex = floor(this.t * FPS);
    const persons = this.poseLoader.poseMap.get(frameIndex) || [];

    // choose middle person index robustly: for N persons, choose Math.floor((N-1)/2)
    const midPersonIndex = Math.floor((persons.length - 1) / 2);

    push(); translate(this.offset.x, this.offset.y); scale(this.scale);

    // bones
    stroke(255,255,0,this.alpha); strokeWeight(max(3,4/this.scale)); noFill();
    for(let p=0;p<persons.length;p++){
      const k = persons[p];
      for(let e=0;e<EDGES.length;e++){
        const a = k[EDGES[e][0]], b = k[EDGES[e][1]]; if(!a||!b) continue;
        line(a[0]*this._scaleX, a[1]*this._scaleY, b[0]*this._scaleX, b[1]*this._scaleY);
      }
    }

    // markers, labels, emoji, and on-canvas pose arrays
    noStroke(); fill(255,0,0,this.alpha); textAlign(CENTER,CENTER);
    const roseSize = this.roseBasePx * this.roseScale; const yOff = this.ptSize * this.roseYOffset; const lblSize = max(10, 14/this.scale);

    for(let p=0;p<persons.length;p++){
      const k = persons[p];
      const centroid = avgPoint(k);

      // compute a robust head/neck position:
      // nose = 0, left shoulder = 5, right shoulder = 6
      const nose = k[0], lShoulder = k[5], rShoulder = k[6];
      let headPos = null;
      let headAngle = 0;
      if(nose){
        if(lShoulder && rShoulder){
          const shMid = [(lShoulder[0]+rShoulder[0])/2, (lShoulder[1]+rShoulder[1])/2];
          // blend nose and shoulder-mid to place head slightly above neck
          headPos = [ nose[0]*0.45 + shMid[0]*0.55, nose[1]*0.35 + shMid[1]*0.65 - 8 ];
          headAngle = atan2(shMid[1]-nose[1], shMid[0]-nose[0]);
        } else {
          headPos = [ nose[0], nose[1] - 18 ];
          headAngle = 0;
        }
      }

      // draw keypoints and emoji (points)
      for(let i=0;i<k.length;i++){
        const pt = k[i]; if(!pt) continue; const x = pt[0]*this._scaleX, y = pt[1]*this._scaleY;
        fill(255,255,255, this.alpha);
        ellipse(x,y,this.ptSize);

        if(this.ui.showLabels){ fill(255,255,255, max(90, this.alpha - 30)); textSize(lblSize); text(i.toString(), x, y - this.ptSize); fill(255,0,0,this.alpha); }

        // place head image at computed headPos (rotating slightly)
        if(this.headImg && headPos && i===0){ // draw once per person when encountering nose index
          push();
          translate(headPos[0]*this._scaleX, headPos[1]*this._scaleY);
          rotate(headAngle);
          imageMode(CENTER);
          // scale head image to proportion of shoulders distance (if available)
          let hs = this.headSize;
          if(lShoulder && rShoulder){
            const shoulderDist = dist2(lShoulder, rShoulder)**0.5;
            // roughly scale head size proportional to shoulder width (clamped)
            const s = constrain(shoulderDist * 0.9, 40, 220);
            hs = s;
          }
          // hs is in pose-space, convert to canvas by multiplying scale & _scaleX; but since we already scale() earlier and then multiply by _scaleX when drawing other points,
          // keep similar mapping: draw using hs*this._scaleX for width & height
          const drawSize = hs * this._scaleX;
          tint(255, this.alpha);
          image(this.headImg, 0, 0, drawSize, drawSize);
          pop();
        }

        // place emoji(s) on wrists: left wrist (9), right wrist (10)
        if((i === 9) || (i === 10)){
          push();
          textAlign(CENTER,CENTER);
          textSize(roseSize);
          const useEmoji = (i===10 && p===midPersonIndex) ? GLORIOSA_EMOJI : ROSE_EMOJI;
          // small bob/rotation for more "holding" realism based on nearby elbow
          let rot = 0;
          const elbow = (i===10) ? k[8] : k[7]; // right elbow = 8, left elbow = 7 (approx)
          if(elbow && pt){
            rot = atan2(pt[1]-elbow[1], pt[0]-elbow[0]) * 0.25;
            rotate(rot);
          }
          fill(255,255,255,this.alpha);
          text(useEmoji, pt[0]*this._scaleX, pt[1]*this._scaleY - yOff);
          pop();
        }
      }

      // draw pose array next to centroid
      if(centroid){
        const arrLimit = this.showFullPoseOnCanvas ? (k.length || 0) : 8;
        const arrStr = formatKptsArray(k, arrLimit, this.showFullPoseOnCanvas);
        push(); textAlign(LEFT, CENTER); textSize(12); fill(220); const tx = centroid[0]*this._scaleX + 12; const ty = centroid[1]*this._scaleY; text(clampStr(arrStr, 240), tx, ty); pop();
      }
    }
    pop();

    this._updateTrails(frameIndex, persons);
  }

  _updateTrails(frameIndex, persons){ if((frameIndex % this.trailSkip) !== 0) return; for(let pi=0; pi<persons.length; pi++){ if(!this.trails[pi]) this.trails[pi] = {}; const kpts = persons[pi]; for(let ki=0; ki<kpts.length; ki++){ const p = kpts[ki]; if(!p) continue; const arr = (this.trails[pi][ki] ||= []); arr.push({x:p[0], y:p[1]}); if(arr.length > this.maxTrail) arr.shift(); } } }

  _drawTrails(){ push(); translate(this.offset.x, this.offset.y); scale(this.scale); const baseW = max(1.25, this.trailWeight / this.scale);
    for(const piStr in this.trails){ const pi = Number(piStr); const [r,g,b] = this.trailColors[pi % this.trailColors.length]; const parts = this.trails[pi]; for(const kiStr in parts){ const pts = parts[kiStr]; if(!pts || pts.length<2) continue; strokeWeight(baseW); for(let s=1;s<pts.length;s++){ const a = lerp(40,this.trailAlpha, s/pts.length); stroke(r,g,b,a); const p1 = pts[s-1], p2 = pts[s]; line(p1.x * this._scaleX, p1.y * this._scaleY, p2.x * this._scaleX, p2.y * this._scaleY); } } } pop(); }

  // transport
  play(){ this.playing = true; if(this.video && this.videoReady()) try{ this.video.play(); this.video.speed(this.rate); }catch(e){} }
  pause(){ this.playing = false; if(this.video) try{ this.video.pause(); }catch(e){} }
  stop(){ this.playing=false; this.t=0; if(this.video) try{ this.video.pause(); this.video.time(0); }catch(e){} }
  videoReady(){ return this.video && this.video.elt && this.video.elt.readyState >= 2; }

  // input
  onKey(k){ if(k==='T') this.showTrails = !this.showTrails; if(k==='P') (this.playing? this.pause() : this.play()); if(k==='L') this.ui.showLabels = !this.ui.showLabels; if(k==='C') this.trails = {}; if(k==='J') this.ui.toggleJSON(); if(k==='[') this.ui.scrollJSON(-3); if(k===']') this.ui.scrollJSON(+3); }
  onMousePressed(){ if(this.ui.mousePressed()) return; this.drag.on = true; this.drag.dx = mouseX - this.offset.x; this.drag.dy = mouseY - this.offset.y; }
  onMouseDragged(){ if(!this.drag.on) return; this.offset.x = mouseX - this.drag.dx; this.offset.y = mouseY - this.drag.dy; }
  onMouseReleased(){ if(this.ui.mouseReleased()) return; this.drag.on = false; }

  saveWindowJSON(startSec=0, durationSec=2){ if(!this.poseLoader.ready) return; startSec = max(0, Number(startSec)||0); durationSec = max(0, Number(durationSec)||0); const vd = (this.video && isFinite(this.video.elt.duration))? this.video.elt.duration : Infinity; const startF = max(0, floor(startSec * FPS)); const endFExcl = min(floor((startSec+durationSec)*FPS), floor((isFinite(vd)?vd:Infinity)*FPS)+1); const hardEnd = min(endFExcl, this.poseLoader.lastFrame + 1);
    const out = []; for(let f=startF; f<hardEnd; f++){ const rel = f - startF; const persons = this.poseLoader.poseMap.get(f) || []; const personsCopy = persons.map(kpts => kpts.map(p => (p ? [p[0], p[1], p[2] ?? 1] : null))); out.push({ frame_id: rel, time_sec: +(rel / FPS).toFixed(3), persons: personsCopy }); }
    saveJSON(out, `pose_segment_rel_${startSec.toFixed(2)}-${(startSec+durationSec).toFixed(2)}s.json`);
  }

  // ---- new helper: produce pretty formatted pose array string ----
  getPoseArrayString(frameIndex=null, personIndex=null, gapLines=1){
    if(!this.poseLoader.ready) return 'Pose JSON not loaded';
    frameIndex = (frameIndex===null) ? floor(this.t*FPS) : frameIndex;
    const persons = this.poseLoader.poseMap.get(frameIndex);
    if(!persons || persons.length===0) return `frame ${frameIndex}: no persons`;

    const lines = [];
    for(let pi=0; pi<persons.length; pi++){
      if(personIndex!==null && pi !== personIndex) continue;
      const k = persons[pi];
      lines.push(`Person[${pi}] â€” keypoints: ${k.length}`);
      for(let ki=0; ki<k.length; ki++){
        const p = k[ki];
        if(!p) lines.push(`  [${ki}]: null`);
        else {
          const x = (typeof p[0] === 'number') ? +p[0].toFixed(2) : p[0];
          const y = (typeof p[1] === 'number') ? +p[1].toFixed(2) : p[1];
          const s = (p.length>=3 && p[2]!=null) ? +p[2].toFixed(3) : 1.0;
          lines.push(`  [${ki}]: [${x}, ${y}, ${s}]`);
        }
      }
      // gap between persons
      for(let g=0; g<gapLines; g++) lines.push('');
    }
    return `frame: ${frameIndex}\n` + lines.join('\n');
  }
}

// ------------------------- UIManager -------------------------
class UIManager{
  constructor(app){ this.app = app; this.items = []; this._active = null; this.jsonOpen = false; this.showLabels = false; this.jsonScroll = 0; }

  build(){ const y = height - 130; const row = (i)=> y + i*36; const right = width - 12;
    this.add(new UIButton(12, row(0), 64, 'Play', ()=>this.app.play()));
    this.add(new UIButton(80, row(0), 64, 'Pause', ()=>this.app.pause()));
    this.add(new UIButton(148, row(0), 64, 'Stop', ()=>this.app.stop()));
    this.add(new UIButton(216, row(0), 72, 'Scale', ()=>{ this.app.scaleIdx = (this.app.scaleIdx + 1) % this.app.scaleCycle.length; this.app.scale = this.app.scaleCycle[this.app.scaleIdx]; this.app.ptIdx = (this.app.ptIdx + 1) % this.app.pointSizes.length; this.app.ptSize = this.app.pointSizes[this.ptIdx]; }));
    this.add(new UIButton(294, row(0), 120, 'Toggle Trails', ()=> this.app.showTrails = !this.app.showTrails));
    this.add(new UIButton(418, row(0), 110, 'Clear Trails', ()=> { this.app.trails = {}; }));
    this.add(new UIButton(532, row(0), 100, 'Labels (L)', ()=> { this.app.ui.showLabels = !this.app.ui.showLabels; }));
    this.add(new UIButton(right - 78, row(0), 66, 'JSON', ()=>{ this.toggleJSON(); }));

    // sliders
    this.add(new UILabel(12, row(1), 'Speed')); this.add(new UISlider(70, row(1), 200, 0.25, 2.0, this.app.rate, 0.01, (v)=>{ this.app.rate=v; if(this.app.video) try{ this.app.video.speed(v);}catch(e){} }));
    this.add(new UILabel(280, row(1), 'Alpha')); this.add(new UISlider(336, row(1), 200, 0, 255, this.app.alpha, 1, (v)=>{ this.app.alpha=v|0; }));
    this.add(new UILabel(548, row(1), 'Trail Len')); this.add(new UISlider(620, row(1), 220, 10, 600, this.app.maxTrail, 1, (v)=>{ this.app.maxTrail=v|0; }));
    this.add(new UILabel(848, row(1), 'Thick')); this.add(new UISlider(898, row(1), 150, 1, 8, this.app.trailWeight, 0.5, (v)=>{ this.app.trailWeight=v; }));

    // steppers + export
    this.add(new UILabel(12, row(2), 'Start(s)')); this.add(new UIStepper(76, row(2), 120, 0.00, 0.05, 0, 9999, (v)=>{}));
    this.add(new UILabel(206, row(2), 'Dur(s)')); this.add(new UIStepper(256, row(2), 120, 2.00, 0.05, 0, 9999, (v)=>{}));
    this.add(new UIButton(386, row(2), 110, 'â†˜ Start=Now', ()=>{ /* read current time and set connected steppers if you wire them */ }));
    this.add(new UIButton(right-420, row(2), 120, 'Save 0â€“2s', ()=> this.app.saveWindowJSON(0,2)));
    this.add(new UIButton(right-294, row(2), 120, 'Save 0â€“5s', ()=> this.app.saveWindowJSON(0,5)));
    this.add(new UIButton(right-168, row(2), 156, 'Save Range', ()=> this.app.saveWindowJSON(0,2)));

    // extras: Frame Gap, Dedupe, FullPose toggle
    this.add(new UILabel(12, row(3), 'Frame Gap')); this.add(new UITextBox(80, row(3), 120, '1', (v)=>{ const n = max(1, Math.floor(Number(v) || 1)); this.app.trailSkip = n; }));
    this.add(new UILabel(220, row(3), 'Dedupe(px)')); this.add(new UITextBox(300, row(3), 120, '8', (v)=>{ const n = max(0, Number(v) || 0); this.app.poseLoader.dedupeFrames(n); }));
    this.add(new UICheckbox(440, row(3)+4, 'Full Pose', false, (checked)=>{ this.app.showFullPoseOnCanvas = checked; }));

    // init button
    this.initBtn = new UIButton(width/2 - 100, height/2 - 32, 200, 'Start / Init', ()=> this.app._userInit()); this.add(this.initBtn);

    // ---- Pose array textbox + controls ----
    this.poseBox = new UITextBox(440, row(2)-36, 520, ''); this.add(this.poseBox);
    this.add(new UIButton(972, row(2)-36, 88, 'Show Pose', ()=> {
      const s = this.app.getPoseArrayString( Math.floor(this.app.t*FPS), null, 1 );
      this.poseBox.value = s;
    }));
    this.add(new UIButton(1064, row(2)-36, 64, 'Copy', ()=> {
      const txt = this.poseBox.value || '';
      if(navigator && navigator.clipboard && navigator.clipboard.writeText){
        navigator.clipboard.writeText(txt).then(()=> {
          // silent success
        }).catch((e)=> {
          alert('Copy failed; opening prompt. Use Ctrl+C to copy.');
          prompt('Copy pose text:', txt);
        });
      } else {
        prompt('Copy pose text:', txt);
      }
    }));

    // ---- Parade controls (new) ----
    this.add(new UICheckbox(972, row(0)+6, 'Parade', false, (checked)=>{ this.app.showParade = checked; }));
    this.add(new UILabel(1040, row(0)+6, 'Count'));
    this.add(new UIStepper(1090, row(0)+6, 100, this.app.paradeCount, 1, 1, 99, (v)=>{ this.app.paradeCount = Math.max(1, Math.round(v)); }));

    // -----------------------------------------------------------------
  }

  add(w){ this.items.push(w); w.ui=this; return w; }
  draw(){ for(const w of this.items) w.draw(); if(this.jsonOpen) this._drawJSONPanel(); }

  mousePressed(){ for(let i=this.items.length-1;i>=0;i--){ const w=this.items[i]; if(w.mousePressed && w.contains(mouseX,mouseY)){ this._active=w; w.mousePressed(); return true; } } return false; }
  mouseDragged(){ if(this._active && this._active.mouseDragged) this._active.mouseDragged(); }
  mouseReleased(){ if(this._active && this._active.mouseReleased) this._active.mouseReleased(); this._active=null; return true; }

  toggleJSON(){ this.jsonOpen = !this.jsonOpen; this.jsonScroll = 0; }
  scrollJSON(delta){ this.jsonScroll = constrain(this.jsonScroll + delta, 0, 9999); }

  _drawJSONPanel(){ const w = 420; const h = height - 32; const x = width - w - 12; const y = 16; const pad=12; const headerH=28; const lineH=16; push(); noStroke(); fill(14,16,20,230); rect(x,y,w,h,8); fill(255); textAlign(LEFT,CENTER); textSize(14); const frameIndex = floor(this.app.t * FPS); const totalFrames = this.app.poseLoader.lastFrame > 0 ? (this.app.poseLoader.lastFrame+1) : 'n/a'; text(`JSON Inspector â€” frame ${frameIndex} / ${totalFrames}`, x + pad, y + headerH/2); textSize(11); fill(200); text('Toggle: J   Scroll: mouse wheel / [ ]', x + pad, y + headerH - 6);

    if(!this.app.poseLoader.ready){ fill(180); textAlign(CENTER,CENTER); textSize(12); text('Pose JSON not loaded', x + w/2, y + h/2); pop(); return; }

    const persons = this.app.poseLoader.poseMap.get(frameIndex) || [];
    const rows = [];
    rows.push(`frame: ${frameIndex}  persons: ${persons.length}`);
    for(let pi=0; pi<persons.length; pi++){ const kpts = persons[pi]; rows.push(` person[${pi}] keypoints: ${kpts.length}`); for(let ki=0; ki<kpts.length; ki++){ const p = kpts[ki]; if(!p) rows.push(`   [${ki}]: null`); else{ const xval = (typeof p[0] === 'number') ? p[0].toFixed(1) : String(p[0]); const yval = (typeof p[1] === 'number') ? p[1].toFixed(1) : String(p[1]); const score = (p.length>=3 && p[2]!=null) ? (typeof p[2]==='number' ? p[2].toFixed(2) : String(p[2])) : '1.00'; rows.push(`   [${ki}]: x=${xval}, y=${yval}, s=${score}`); } } }

    const total = rows.length; const maxRows = 18; this.jsonScroll = constrain(this.jsonScroll, 0, Math.max(0, total - maxRows)); const start = this.jsonScroll; const end = min(total, start + maxRows);

    push(); translate(x + pad, y + headerH + 6); noStroke(); fill(255); textAlign(LEFT, TOP); textSize(12); let ty = 0; for(let r=start; r<end; r++){ const str = rows[r]; if(str.startsWith('frame:')) fill(180,255,180); else if(str.trim().startsWith('person[')) fill(180,220,255); else fill(210); text(str, 0, ty); ty += lineH; } pop();

    push(); fill(40,80); noStroke(); const trackX = x + w - pad*1.5 - 6; const trackY = y + headerH + 6; rect(trackX, trackY, 6, h - headerH - 12, 3); const thumbH = max(20, (maxRows / max(1,total)) * (h - headerH - 12)); const thumbYRange = (h - headerH - 12) - thumbH; const thumbY = (total <= maxRows) ? 0 : (this.jsonScroll / (total - maxRows)) * thumbYRange; fill(200,140); rect(trackX, trackY + thumbY, 6, thumbH, 3); pop();

    pop(); }
}

// ------------------------- end of file -------------------------

/* Summary of the key changes made:
 - Head image placement improved: head is placed using nose + shoulder midpoint (gives natural head/neck position) and rotated a bit to match orientation.
 - Rose/gloriosa emoji placed on both wrists (left=9, right=10). Right wrist uses GLORIOSA for middle person by default.
 - Parade: animated row of rose emojis walking along bottom of screen (toggleable via UI).
 - UI controls added: Parade checkbox + parade count stepper; Show Pose + Copy remain.
 - Kept existing features: trails, pose inspector, save JSON, scaling, etc.
*/
